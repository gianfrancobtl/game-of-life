        -:    0:Source:/Users/gianbattolla/Documents/Año 2020 - Cs. de la computación/Algoritmos y Estructuras de Datos 1/Trabajo Practico de Implementación - Juego de la Vida-20201031/tpi_final/ejercicios.cpp
        -:    0:Graph:/Users/gianbattolla/Documents/Año 2020 - Cs. de la computación/Algoritmos y Estructuras de Datos 1/Trabajo Practico de Implementación - Juego de la Vida-20201031/tpi_final/cmake-build-debug/CMakeFiles/juegoDeLaVida.dir/ejercicios.gcno
        -:    0:Data:/Users/gianbattolla/Documents/Año 2020 - Cs. de la computación/Algoritmos y Estructuras de Datos 1/Trabajo Practico de Implementación - Juego de la Vida-20201031/tpi_final/cmake-build-debug/CMakeFiles/juegoDeLaVida.dir/ejercicios.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <algorithm>
        -:    2:#include "ejercicios.h"
        -:    3:#include "auxiliares.h"
        -:    4:
        -:    5:// EJERCICIO 1
        3:    6:bool toroideValido(vector<vector<bool>> const &t) {
        3:    6-block  0
        3:    7:    bool resp = false;
        3:    8:    if (cantFilas(t) >= 3 && cantColumnas(t) >= 3 && esRectangulo(t))
        3:    8-block  0
        2:    8-block  1
        1:    8-block  2
        1:    9:        resp = true;
        1:    9-block  0
        3:   10:    return resp;
        3:   10-block  0
        -:   11:}
        -:   12:
        -:   13:// EJERCICIO 2
        2:   14:vector<posicion> posicionesVivas(toroide const &t) {
        2:   14-block  0
        2:   15:    vector<posicion> vivos;
       13:   16:    for (int i = 0; i < cantFilas(t); i ++){
        2:   16-block  0
       13:   16-block  1
       13:   16-block  2
       11:   16-block  3
       49:   17:        for (int j = 0 ; j < cantColumnas(t); j ++){
       11:   17-block  0
       49:   17-block  1
       49:   17-block  2
       38:   17-block  3
       38:   18:            if (t[i][j])
       38:   18-block  0
       38:   18-block  1
       26:   19:                vivos.push_back(mp(i,j));
       26:   19-block  0
       26:   19-block  1
       26:   19-block  2
       38:   20:        }
       38:   20-block  0
       11:   21:    }
       11:   21-block  0
        2:   22:    return vivos;
        2:   23:}
    $$$$$:   23-block  0
        2:   23-block  1
    $$$$$:   23-block  2
        2:   23-block  3
    $$$$$:   23-block  4
        -:   24:
        -:   25:// EJERCICIO 3
        1:   26:float densidadPoblacion(toroide const &t) {
        1:   26-block  0
        1:   27:    float cantidadViva = posicionesVivas(t).size();
        1:   28:    float superficieTotal = float(cantFilas(t)) * float(cantColumnas(t));
        1:   29:    return cantidadViva / superficieTotal;
        1:   29-block  0
        -:   30:}
        -:   31:
        -:   32:// EJERCICIO 4
      269:   33:bool evolucionDePosicion(toroide const &t, posicion x) {
      269:   33-block  0
        -:   34:    bool resp;
      474:   35:    if ((estaViva(t, x) && (cantVecinosVivos(t, x) == 2 || cantVecinosVivos(t, x) == 3)) ||
      269:   35-block  0
       64:   35-block  1
       42:   35-block  2
      205:   35-block  3
      247:   36:    (!estaViva(t, x) && cantVecinosVivos(t, x) == 3))
      247:   36-block  0
       64:   37:        resp = true;
       64:   37-block  0
        -:   38:    else
      205:   39:        resp = false;
      205:   39-block  0
        -:   40:
      269:   41:    return resp;
      269:   41-block  0
        -:   42:}
        -:   43:
        -:   44:// EJERCICIO 5
       17:   45:void evolucionToroide(toroide &t){
       17:   45-block  0
       17:   46:    toroide toroideOriginal = t;
       86:   47:    for (int i = 0; i < cantFilas(t); i ++) {
       17:   47-block  0
       86:   47-block  1
       86:   47-block  2
       69:   47-block  3
      336:   48:        for (int j = 0; j < cantColumnas(t); j++) {
       69:   48-block  0
      336:   48-block  1
      336:   48-block  2
      267:   48-block  3
      267:   49:            t[i][j] = evolucionDePosicion(toroideOriginal, mp(i, j));
      267:   49-block  0
      267:   49-block  1
      267:   49-block  2
      267:   50:        }
      267:   50-block  0
       69:   51:    }
       69:   51-block  0
       17:   52:}
    $$$$$:   52-block  0
       17:   52-block  1
    $$$$$:   52-block  2
        -:   53:
        -:   54:// EJERCICIO 6
        1:   55:toroide evolucionMultiple(toroide const &t, int K) {
        1:   55-block  0
        1:   56:    toroide out = t;
        2:   57:    for (int k = K; k > 0; k --)
        1:   57-block  0
        2:   57-block  1
        1:   57-block  2
        1:   58:        evolucionToroide(out);
        1:   58-block  0
        1:   58-block  1
        1:   59:    return out;
        1:   60:}
    $$$$$:   60-block  0
        1:   60-block  1
    $$$$$:   60-block  2
        1:   60-block  3
    $$$$$:   60-block  4
        -:   61:
        -:   62:// EJERCICIO 7
        1:   63:bool esPeriodico(toroide const& t, int &p) {
        1:   63-block  0
        1:   64:    bool resp = false;
        1:   65:    p = 0;
        1:   66:    toroide toroideOut = t;
        3:   67:    while (!toroideMuerto(toroideOut) && !resp){
        1:   67-block  0
        3:   67-block  1
        3:   67-block  2
        3:   67-block  3
        3:   67-block  4
        2:   67-block  5
        2:   68:        p ++;
        2:   69:        evolucionToroide(toroideOut);
        2:   69-block  0
        2:   70:        if (t == toroideOut)
        2:   70-block  0
        2:   70-block  1
        1:   71:            resp = true;
        1:   71-block  0
        -:   72:    }
        1:   73:    return resp;
        1:   74:}
    $$$$$:   74-block  0
        1:   74-block  1
    $$$$$:   74-block  2
        -:   75:
        -:   76:// EJERCICIO 8
        2:   77:bool primosLejanos(toroide const &t, toroide const &u) {
        2:   77-block  0
        2:   78:    bool resp = false;
        2:   79:    toroide genericoT = t;
        2:   80:    toroide genericoU = u;
        2:   80-block  0
        4:   81:    while (!toroideMuerto(genericoT) && !toroideMuerto(genericoU) && !resp){
        2:   81-block  0
        4:   81-block  1
        4:   81-block  2
        4:   81-block  3
        4:   81-block  4
        4:   81-block  5
        4:   81-block  6
        2:   81-block  7
        2:   82:        evolucionToroide(genericoT);
        2:   82-block  0
        2:   83:        evolucionToroide(genericoU);
        2:   83-block  0
        2:   84:        if ( genericoT == u || genericoU == t)
        2:   84-block  0
        2:   84-block  1
    $$$$$:   84-block  2
    $$$$$:   84-block  3
        2:   85:            resp = true;
        2:   85-block  0
        -:   86:    }
        2:   87:    return resp;
        2:   88:}
    $$$$$:   88-block  0
    $$$$$:   88-block  1
        2:   88-block  2
    $$$$$:   88-block  3
    $$$$$:   88-block  4
        -:   89:
        -:   90:// EJERCICIO 9
        2:   91:int seleccionNatural(vector <toroide> ts) {
        2:   92:    int resp = -1;
        2:   92-block  0
        2:   93:    int mayorCantTicks = -1;
        8:   94:    for (int i = 0; i < ts.size(); i ++){
        2:   94-block  0
        8:   94-block  1
        6:   94-block  2
        6:   95:        toroide evoT = ts[i];
        6:   96:        int k = 0;
       15:   97:        while (!toroideMuerto(evoT)){
        6:   97-block  0
       15:   97-block  1
       15:   97-block  2
        9:   97-block  3
        9:   98:            evolucionToroide(evoT);
        9:   98-block  0
        9:   99:            k ++;
        -:  100:        }
        6:  101:        if (k > mayorCantTicks){
        6:  101-block  0
        2:  102:            resp = i;
        2:  103:            mayorCantTicks = k;
        2:  104:        }
        2:  104-block  0
        6:  105:    }
    $$$$$:  105-block  0
        6:  105-block  1
    $$$$$:  105-block  2
        2:  106:    return resp;
        2:  106-block  0
    #####:  107:}
        -:  108:
        -:  109:
        -:  110:// EJERCICIO 10
        1:  111:toroide fusionar(toroide const &t, toroide const &u) {
        1:  111-block  0
        1:  112:    toroide out (cantFilas(t), vector<bool>(cantColumnas(t)));
        1:  112-block  0
    $$$$$:  112-block  1
    $$$$$:  112-block  2
        4:  113:    for (int i = 0; i < cantFilas(t); i ++) {
        1:  113-block  0
        4:  113-block  1
        4:  113-block  2
        3:  113-block  3
       12:  114:        for (int j = 0; j < cantColumnas(t); j ++) {
        3:  114-block  0
       12:  114-block  1
       12:  114-block  2
        9:  114-block  3
        9:  115:            if (t[i][j] && u[i][j])
        9:  115-block  0
        9:  115-block  1
        3:  115-block  2
        3:  115-block  3
        9:  115-block  4
    #####:  116:                out [i][j] = true;
    $$$$$:  116-block  0
    $$$$$:  116-block  1
        -:  117:            else
        9:  118:                out [i][j] = false;
        9:  118-block  0
        9:  118-block  1
        9:  119:        }
        9:  119-block  0
        3:  120:    }
        3:  120-block  0
        1:  121:    return out;
        1:  122:}
    $$$$$:  122-block  0
        1:  122-block  1
    $$$$$:  122-block  2
        1:  122-block  3
        -:  123:
        -:  124:// EJERCICIO 11
        2:  125:bool vistaTrasladada(toroide const &t, toroide const &u){
        2:  125-block  0
        2:  126:    bool resp = false;
        6:  127:    for (int i = 0; i < cantFilas(t) && !resp ; ++i) {
        2:  127-block  0
        6:  127-block  1
        5:  127-block  2
        6:  127-block  3
        4:  127-block  4
       16:  128:        for (int j = 0; j < cantColumnas(t) ; ++j) {
        4:  128-block  0
       16:  128-block  1
       12:  128-block  2
       12:  129:            if (traslacion(t,i,j) == u)
       12:  129-block  0
       12:  129-block  1
       12:  129-block  2
    $$$$$:  129-block  3
    $$$$$:  129-block  4
    $$$$$:  129-block  5
        1:  130:                resp = true;
        1:  130-block  0
       12:  131:        }
       12:  131-block  0
        4:  132:    }
        4:  132-block  0
        2:  133:    return resp;
        2:  133-block  0
    #####:  134:}
    $$$$$:  134-block  0
        -:  135:
        -:  136:// EJERCICIO 12
        1:  137:int menorSuperficieViva(toroide const &t){
        1:  137-block  0
        1:  138:    int resp = areaTotal(t);
        5:  139:    for (int i = 0; i < t.size() ; ++ i) {
        1:  139-block  0
        5:  139-block  1
        4:  139-block  2
       20:  140:        for (int j = 0; j < t[0].size() ; ++ j) {
        4:  140-block  0
       20:  140-block  1
       16:  140-block  2
       16:  141:            if (resp > areaTotal(traslacion(t,i,j)))
       16:  141-block  0
       16:  141-block  1
       16:  141-block  2
    $$$$$:  141-block  3
    $$$$$:  141-block  4
    $$$$$:  141-block  5
        3:  142:                resp = areaTotal(traslacion(t,i,j));
        3:  142-block  0
        3:  142-block  1
        3:  142-block  2
    $$$$$:  142-block  3
    $$$$$:  142-block  4
       16:  143:        }
       16:  143-block  0
        4:  144:    }
        4:  144-block  0
        1:  145:    return resp;
        1:  145-block  0
    #####:  146:}
    $$$$$:  146-block  0
    $$$$$:  146-block  1
